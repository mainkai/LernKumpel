<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mal-Atelier</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-8px); }
        }
        .animate-float { animation: float 2.6s ease-in-out infinite; }

        @keyframes popIn {
            0% { transform: scale(0.9); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        .animate-pop-in { animation: popIn 0.28s ease-out; }

        @keyframes scoreReveal {
          0% { transform: translateY(8px) scale(0.92); opacity: 0; }
          65% { transform: translateY(-2px) scale(1.05); opacity: 1; }
          100% { transform: translateY(0) scale(1); opacity: 1; }
        }
        .animate-score-reveal { animation: scoreReveal 0.42s ease-out; }

        body { overscroll-behavior-y: none; }
        canvas { touch-action: none; }
    </style>

    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="importmap">
      {
        "imports": {
          "firebase/app": "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js",
          "firebase/auth": "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js",
          "firebase/firestore": "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js"
        }
      }
    </script>
</head>
<body class="bg-indigo-100">
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import { initializeApp } from 'firebase/app';
        import { getAuth, signInAnonymously, onAuthStateChanged } from 'firebase/auth';
        import { getFirestore, doc, onSnapshot, setDoc, updateDoc, getDoc, arrayUnion, collection, query, where, documentId } from 'firebase/firestore';

        const { useState, useEffect, useRef, useMemo, useCallback } = React;

        const Users = ({size=20, className=""}) => (
          <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>
            <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path>
            <circle cx="9" cy="7" r="4"></circle>
            <path d="M23 21v-2a4 4 0 0 0-3-3.87"></path>
            <path d="M16 3.13a4 4 0 0 1 0 7.75"></path>
          </svg>
        );

        const ScoreRing = ({ score = 0, max = 100 }) => {
          const safeMax = Math.max(1, max);
          const safeScore = clamp(Math.round(score), 0, safeMax);
          const size = 80;
          const strokeWidth = 10;
          const normalizedRadius = (size - strokeWidth) / 2;
          const circumference = 2 * Math.PI * normalizedRadius;
          const strokeDashoffset = circumference * (1 - safeScore / safeMax);

          return (
            <div className="mt-3 flex justify-center">
              <div className="w-20 h-20 relative shrink-0">
                <svg viewBox={`0 0 ${size} ${size}`} className="w-full h-full -rotate-90">
                  <circle
                    cx={size / 2}
                    cy={size / 2}
                    r={normalizedRadius}
                    fill="none"
                    stroke="#c7d2fe"
                    strokeWidth={strokeWidth}
                  />
                  <circle
                    cx={size / 2}
                    cy={size / 2}
                    r={normalizedRadius}
                    fill="none"
                    stroke="#4f46e5"
                    strokeWidth={strokeWidth}
                    strokeLinecap="round"
                    strokeDasharray={circumference}
                    strokeDashoffset={strokeDashoffset}
                    style={{ transition: 'stroke-dashoffset 420ms ease-out' }}
                  />
                </svg>
                <div className="absolute inset-0 flex items-center justify-center leading-none">
                  <span className="text-indigo-900 font-black text-lg">+{safeScore}</span>
                </div>
              </div>
            </div>
          );
        };

        const AVATAR_POOL = ['ðŸ¦Š', 'ðŸ°', 'ðŸ¦', 'ðŸ¶', 'ðŸ±', 'ðŸ­', 'ðŸ¹', 'ðŸ»', 'ðŸ¼', 'ðŸ¨', 'ðŸ¯', 'ðŸ¸', 'ðŸµ', 'ðŸ¦‰', 'ðŸ§'];
        const BRUSH_COLORS = ['#111827', '#ef4444', '#f97316', '#eab308', '#22c55e', '#0ea5e9', '#6366f1', '#ec4899', '#8b5a2b', '#a16207', '#6b7280', '#9ca3af'];
        const MAX_ROUNDS = 5;
        const UNDO_LIMIT = 25;
        const AI_EDIT_COST = 50;
        const EVALUATION_MODEL_OPTIONS = [
          { value: 'google/gemini-3-flash-preview', label: 'Gemini 3 Flash Preview - ? $/request, very fast, good' },
          { value: 'bytedance-seed/seed-1.6-flash', label: 'Seed 1.6 Flash - ? $/request, fast, good' },
          { value: 'qwen/qwen3.5-flash-02-23', label: 'Qwen3.5-Flash - ? $/request, very fast, good' },
          { value: 'openai/gpt-4o-mini', label: 'GPT-4o Mini - 0.0041 $/request, fast, cheap and good' },
          { value: 'bytedance-seed/seed-2.0-mini', label: 'Seed-2.0-Mini - ? $/request, very fast, good' },
          { value: 'x-ai/grok-4.1-fast', label: 'Grok 4.1 Fast - ? $/request, fast, good' },
          { value: 'google/gemini-2.5-flash-lite-preview-09-2025', label: 'Gemini 2.5 Flash Lite Preview 09-2025 - ? $/request, very fast, ok' },
          { value: 'nvidia/nemotron-nano-12b-v2-vl:free', label: 'Nemotron Nano 12B 2 VL (free) - 0 $/request, slow, ok' },
          { value: 'openai/gpt-5-nano', label: 'GPT-5 Nano - ? $/request, slow, ok' },
          { value: 'openrouter/free', label: 'Free Models Router - 0 $/request, fast enough, good output. Fails often' },
          { value: 'moonshotai/kimi-k2.5', label: 'Kimi K2.5 - ? $/request, very slow, not so good' }
        ];
        const DEFAULT_EVALUATION_MODEL = EVALUATION_MODEL_OPTIONS[0].value;
        const IMAGE_EDIT_MODEL_OPTIONS = [
          { value: 'black-forest-labs/flux.2-klein-4b', label: 'FLUX.2 Klein 4B - 0.015 $/img, fast, cheap and good' },
          { value: 'sourceful/riverflow-v2-fast', label: 'Riverflow V2 Fast - 0.02 $/img' },
          { value: 'google/gemini-2.5-flash-image', label: 'Nano Banana (Gemini 2.5 Flash Image) - 0.0393 $/img, fast, output good' },
          { value: 'bytedance-seed/seedream-4.5', label: 'Seedream 4.5 - 0.04 $/img, output not convincing' },
          { value: 'openai/gpt-5-image-mini', label: 'GPT-5 Image Mini - 0.0447 $/img, very slow, output is nice though' },
          { value: 'google/gemini-3.1-flash-image-preview', label: 'Nano Banana 2 (Gemini 3.1 Flash Image Preview) - 0.0678 $/img, fast, very nice output' },
          { value: 'black-forest-labs/flux.2-flex', label: 'FLUX.2 Flex - 0.1 $/img, fast, good' },
          { value: 'black-forest-labs/flux.2-max', label: 'FLUX.2 Max - 0.1 $/img, slow, quality ok' },
          { value: 'google/gemini-3-pro-image-preview', label: 'Nano Banana Pro (Gemini 3 Pro Image Preview)- 0.139 $/img, extremely slow, very nice output' },
          { value: 'sourceful/riverflow-v2-pro', label: 'Riverflow V2 Pro - 0.15 $/img' }
        ];
        const DEFAULT_IMAGE_EDIT_MODEL = IMAGE_EDIT_MODEL_OPTIONS[0].value;
        const DIFFICULTY_OPTIONS = [
          { key: 'leicht', label: 'Leicht', symbol: 'ðŸŸ¢', minPoints: 0, maxPoints: 150 },
          { key: 'mittel', label: 'Mittel', symbol: 'ðŸŸ¡', minPoints: 151, maxPoints: 250 },
          { key: 'schwer', label: 'Schwer', symbol: 'ðŸ”´', minPoints: 251, maxPoints: 499 },
          { key: 'ultra_schwer', label: 'Extrem', symbol: 'ðŸŸ£', minPoints: 500, maxPoints: Number.POSITIVE_INFINITY }
        ];
        const DRAW_TASKS = [
            // Leicht (0-150 Punkte)
            { prompt: 'eine Katze', emoji: 'ðŸ±', maxPoints: 100 },
            { prompt: 'eine Rakete', emoji: 'ðŸš€', maxPoints: 100 },
            { prompt: 'einen Regenbogen', emoji: 'ðŸŒˆ', maxPoints: 100 },
            { prompt: 'eine Blume', emoji: 'ðŸŒ¸', maxPoints: 100 },
            { prompt: 'einen Hund', emoji: 'ðŸ¶', maxPoints: 100 },
            { prompt: 'einen Schmetterling', emoji: 'ðŸ¦‹', maxPoints: 100 },
            { prompt: 'einen Vogel', emoji: 'ðŸ¦', maxPoints: 100 },
            { prompt: 'einen Baum', emoji: 'ðŸŒ³', maxPoints: 100 },
            { prompt: 'einen Schneemann', emoji: 'â›„', maxPoints: 100 },
            { prompt: 'einen MarienkÃ¤fer', emoji: 'ðŸž', maxPoints: 100 },
            { prompt: 'einen Frosch', emoji: 'ðŸ¸', maxPoints: 100 },
            
            { prompt: 'einen Fisch im Meer', emoji: 'ðŸŸ', maxPoints: 150 },
            { prompt: 'ein Auto', emoji: 'ðŸš—', maxPoints: 150 },
            { prompt: 'einen Elefanten', emoji: 'ðŸ˜', maxPoints: 150 },
            { prompt: 'einen Apfelbaum', emoji: 'ðŸŽðŸŒ³', maxPoints: 150 },
            { prompt: 'eine Eule', emoji: 'ðŸ¦‰', maxPoints: 150 },
            { prompt: 'eine Giraffe', emoji: 'ðŸ¦’', maxPoints: 150 },
            { prompt: 'einen Affen', emoji: 'ðŸµ', maxPoints: 150 },
            { prompt: 'einen LÃ¶wen', emoji: 'ðŸ¦', maxPoints: 150 },
            { prompt: 'einen Wal im Meer', emoji: 'ðŸ‹', maxPoints: 150 },
            { prompt: 'einen Panda', emoji: 'ðŸ¼', maxPoints: 150 },
            { prompt: 'einen BÃ¤ren', emoji: 'ðŸ»', maxPoints: 150 },
            { prompt: 'einen Regenbogen mit Wolken', emoji: 'ðŸŒˆâ˜ï¸', maxPoints: 150 },
            { prompt: 'einen Schneemann mit Hut', emoji: 'â›„ðŸŽ©', maxPoints: 150 },
            { prompt: 'einen MarienkÃ¤fer auf einem Blatt', emoji: 'ðŸžðŸƒ', maxPoints: 150 },

            // Mittel (151-250 Punkte)
            { prompt: 'ein Haus mit Baum', emoji: 'ðŸ ', maxPoints: 200 },
            { prompt: 'einen Dinosaurier', emoji: 'ðŸ¦–', maxPoints: 200 },
            { prompt: 'eine Prinzessin oder einen Prinzen', emoji: 'ðŸ‘‘', maxPoints: 200 },
            { prompt: 'einen Roboter', emoji: 'ðŸ¤–', maxPoints: 200 },
            { prompt: 'einen Superhelden', emoji: 'ðŸ¦¸', maxPoints: 200 },
            { prompt: 'einen Clown', emoji: 'ðŸ¤¡', maxPoints: 200 },
            { prompt: 'eine Biene auf einer Blume', emoji: 'ðŸðŸŒ¸', maxPoints: 200 },
            { prompt: 'einen Schmetterling auf einer Blume', emoji: 'ðŸ¦‹ðŸŒ¼', maxPoints: 200 },
            { prompt: 'eine Eisdiele', emoji: 'ðŸ¦', maxPoints: 200 },
            { prompt: 'einen Vogel auf einem Ast', emoji: 'ðŸ¦ðŸŒ¿', maxPoints: 200 },
            { prompt: 'einen Apfelbaum mit Ã„pfeln', emoji: 'ðŸŽðŸŒ³', maxPoints: 200 },
            { prompt: 'eine Eule auf einem Ast', emoji: 'ðŸ¦‰ðŸŒ¿', maxPoints: 200 },
            { prompt: 'einen Frosch auf einem Seerosenblatt', emoji: 'ðŸ¸ðŸŒº', maxPoints: 200 },

            { prompt: 'eine Burg', emoji: 'ðŸ°', maxPoints: 250 },
            { prompt: 'einen Drachen', emoji: 'ðŸ‰', maxPoints: 250 },
            { prompt: 'eine Meerjungfrau oder einen Meermann', emoji: 'ðŸ§œ', maxPoints: 250 },
            { prompt: 'eine Rakete zum Mond', emoji: 'ðŸš€ðŸŒ•', maxPoints: 250 },
            { prompt: 'eine Hexe oder einen Zauberer', emoji: 'ðŸ§™', maxPoints: 250 },
            { prompt: 'eine Katze auf einem Baum', emoji: 'ðŸ±ðŸŒ³', maxPoints: 250 },
            { prompt: 'einen Clown mit Luftballons', emoji: 'ðŸ¤¡ðŸŽˆ', maxPoints: 250 },
            { prompt: 'eine Giraffe, die BlÃ¤tter frisst', emoji: 'ðŸ¦’ðŸ‚', maxPoints: 250 },
            { prompt: 'einen Affen, der eine Banane isst', emoji: 'ðŸµðŸŒ', maxPoints: 250 },

            // Schwer (251-499 Punkte)
            { prompt: 'einen Hund, der einen Ball fÃ¤ngt', emoji: 'ðŸ¶âš½', maxPoints: 300 },
            { prompt: 'einen Roboter, der tanzt', emoji: 'ðŸ¤–ðŸ’ƒ', maxPoints: 300 },
            { prompt: 'einen Superhelden, der fliegt', emoji: 'ðŸ¦¸â€â™‚ï¸âœˆï¸', maxPoints: 300 },
            { prompt: 'eine Biene, die Honig macht', emoji: 'ðŸðŸ¯', maxPoints: 300 },
            { prompt: 'ein Piratenschiff im Sturm', emoji: 'ðŸ´â€â˜ ï¸ðŸŒŠ', maxPoints: 300 },
            { prompt: 'eine Zauberschule mit Sternenhimmel', emoji: 'ðŸ°âœ¨', maxPoints: 300 },

            { prompt: 'eine Meerjungfrau unter Wasser', emoji: 'ðŸ§œðŸŒŠ', maxPoints: 350 },
            { prompt: 'einen Drachen, der Ã¼ber eine Burg fliegt', emoji: 'ðŸ‰ðŸ°', maxPoints: 350 },
            { prompt: 'eine Unterwasserstadt mit Fischen', emoji: 'ðŸ™ï¸ðŸ ', maxPoints: 350 },
            { prompt: 'einen Vulkan mit Lava und Dinosauriern', emoji: 'ðŸŒ‹ðŸ¦–', maxPoints: 350 },

            { prompt: 'einen Dinosaurier in der Stadt', emoji: 'ðŸ¦–ðŸ™ï¸', maxPoints: 400 },
            { prompt: 'einen Weltraumbahnhof auf dem Mond', emoji: 'ðŸŒ•ðŸš€', maxPoints: 400 },
            { prompt: 'ein Schloss auf den Wolken', emoji: 'ðŸ°â˜ï¸', maxPoints: 400 },
            { prompt: 'einen Schmetterling, der aus einem Kokon schlÃ¼pft', emoji: 'ðŸ¦‹ðŸ›', maxPoints: 400 },

            // Extrem (500+ Punkte)
            { prompt: 'eine Drachenfamilie Ã¼ber einer leuchtenden Stadt bei Nacht', emoji: 'ðŸ‰ðŸŒƒ', maxPoints: 550 },
            { prompt: 'ein UnterwasserkÃ¶nigreich mit Schloss, Korallen und Schatztruhe', emoji: 'ðŸ‘‘ðŸ°ðŸ ', maxPoints: 550 },
            { prompt: 'eine Zeitreise mit Dinosauriern und Robotern in einer Szene', emoji: 'ðŸ¦–ðŸ¤–â³', maxPoints: 600 },
            { prompt: 'eine Zauberschule im Gewitter mit fliegenden Besen', emoji: 'ðŸ°âš¡ðŸ§¹', maxPoints: 600 },
            { prompt: 'eine Weltraumstadt auf mehreren Planeten mit Raumschiffen', emoji: 'ðŸªðŸ™ï¸ðŸš€', maxPoints: 650 },
            { prompt: 'ein groÃŸes Fantasieabenteuer mit Burg, Drachen, Rittern und Wald', emoji: 'ðŸ°ðŸ‰ðŸ›¡ï¸ðŸŒ²', maxPoints: 700 },
            { prompt: 'eine riesige Traumwelt aus Wolkenschloss, RegenbogenbrÃ¼cke und Sternenmeer', emoji: 'â˜ï¸ðŸ°ðŸŒˆâœ¨', maxPoints: 750 }
          ];

        const firebaseConfig = {
          apiKey: "AIzaSyAsJ-pcrHNgdmAJkM3PgLQt-WZMv1iyMrg",
          authDomain: "zahlensafari.firebaseapp.com",
          projectId: "zahlensafari",
          storageBucket: "zahlensafari.firebasestorage.app",
          messagingSenderId: "569809723706",
          appId: "1:569809723706:web:7a1befeff13b36422c7003"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const APP_ID = 'mal-atelier';
        const DB_COLLECTIONS = {
          devices: 'devices',
          profiles: 'global_profiles',
          appHighscores: 'app_highscores'
        };

        const shuffle = (items) => [...items].sort(() => Math.random() - 0.5);

        const parseJsonFromText = (text) => {
          if (!text) return null;
          const direct = text.trim();
          try {
            return JSON.parse(direct);
          } catch {
            const start = direct.indexOf('{');
            const end = direct.lastIndexOf('}');
            if (start >= 0 && end > start) {
              try {
                return JSON.parse(direct.slice(start, end + 1));
              } catch {
                return null;
              }
            }
            return null;
          }
        };

        const clamp = (value, min, max) => Math.min(max, Math.max(min, value));
        const scoreToEmoji = (score) => {
          if (score >= 90) return 'ðŸ¤©';
          if (score >= 75) return 'ðŸ˜„';
          if (score >= 55) return 'ðŸ™‚';
          if (score >= 35) return 'ðŸ˜…';
          return 'ðŸ«¶';
        };
        const hexToRgb = (hexColor) => {
          const normalized = (hexColor || '').replace('#', '').trim();
          if (normalized.length !== 6) return { r: 0, g: 0, b: 0 };
          const value = Number.parseInt(normalized, 16);
          if (Number.isNaN(value)) return { r: 0, g: 0, b: 0 };
          return {
            r: (value >> 16) & 255,
            g: (value >> 8) & 255,
            b: value & 255
          };
        };
        const fileTimestamp = () => new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
        const extensionFromMime = (mimeType) => {
          if (!mimeType || typeof mimeType !== 'string') return 'png';
          if (mimeType.includes('png')) return 'png';
          if (mimeType.includes('jpeg') || mimeType.includes('jpg')) return 'jpg';
          if (mimeType.includes('webp')) return 'webp';
          if (mimeType.includes('gif')) return 'gif';
          return 'png';
        };
        const sanitizeFilenamePart = (value, fallback = 'datei') => {
          const normalized = (value || '')
            .toString()
            .trim()
            .toLowerCase()
            .normalize('NFD')
            .replace(/[\u0300-\u036f]/g, '')
            .replace(/[^a-z0-9]+/g, '-')
            .replace(/^-+|-+$/g, '')
            .slice(0, 60);

          return normalized || fallback;
        };

        const getCanvasMetrics = (canvas) => {
          const rect = canvas.getBoundingClientRect();
          const style = window.getComputedStyle(canvas);
          const borderLeft = Number.parseFloat(style.borderLeftWidth || '0') || 0;
          const borderRight = Number.parseFloat(style.borderRightWidth || '0') || 0;
          const borderTop = Number.parseFloat(style.borderTopWidth || '0') || 0;
          const borderBottom = Number.parseFloat(style.borderBottomWidth || '0') || 0;

          const cssWidth = Math.max(1, rect.width - borderLeft - borderRight);
          const cssHeight = Math.max(1, rect.height - borderTop - borderBottom);

          return {
            cssWidth,
            cssHeight,
            offsetLeft: rect.left + borderLeft,
            offsetTop: rect.top + borderTop
          };
        };

        function App() {
          const [user, setUser] = useState(null);
          const [linkedProfileIds, setLinkedProfileIds] = useState([]);
          const [profiles, setProfiles] = useState([]);
          const [activeProfileId, setActiveProfileId] = useState(null);
          const [isLoadingProfile, setIsLoadingProfile] = useState(true);
          const [screen, setScreen] = useState('loading');

          const [setupName, setSetupName] = useState('');
          const [setupAvatar, setSetupAvatar] = useState('ðŸ¦Š');

          const [roundTasks, setRoundTasks] = useState([]);
          const [roundIndex, setRoundIndex] = useState(0);
          const [score, setScore] = useState(0);
          const [feedback, setFeedback] = useState('');
          const [lastRoundScore, setLastRoundScore] = useState(0);
          const [lastRoundEmoji, setLastRoundEmoji] = useState('');
          const [lastRoundComment, setLastRoundComment] = useState('');
          const [hasRoundScored, setHasRoundScored] = useState(false);
          const [resultText, setResultText] = useState('');
          const [earnedCoins, setEarnedCoins] = useState(0);
          const [errorText, setErrorText] = useState('');
          const [isBusy, setIsBusy] = useState(false);
          const [isGeneratingImage, setIsGeneratingImage] = useState(false);

          const [brushColor, setBrushColor] = useState(BRUSH_COLORS[0]);
          const [brushSize, setBrushSize] = useState(8);
          const [tool, setTool] = useState('brush');
          const [canUndo, setCanUndo] = useState(false);
          const [generatedImageUrl, setGeneratedImageUrl] = useState('');

          const [openRouterApiKey, setOpenRouterApiKey] = useState(localStorage.getItem('malAtelierOpenRouterKey') || '');
          const [evaluationModel, setEvaluationModel] = useState(DEFAULT_EVALUATION_MODEL);
          const [imageEditModel, setImageEditModel] = useState(DEFAULT_IMAGE_EDIT_MODEL);
          const [selectedDifficulty, setSelectedDifficulty] = useState(DIFFICULTY_OPTIONS[0].key);

          const canvasRef = useRef(null);
          const canvasCssSizeRef = useRef({ width: 0, height: 0 });
          const drawingRef = useRef(false);
          const lastPointRef = useRef(null);
          const undoStackRef = useRef([]);

          const profile = useMemo(() => profiles.find((p) => p.id === activeProfileId), [profiles, activeProfileId]);
          const currentTask = roundTasks[roundIndex] || null;
          const isApiKeyMissing = !openRouterApiKey.trim();

          useEffect(() => {
            localStorage.setItem('malAtelierOpenRouterKey', openRouterApiKey);
          }, [openRouterApiKey]);

          useEffect(() => {
            const initAuth = async () => {
              try {
                await signInAnonymously(auth);
              } catch (err) {
                console.error('Auth error:', err);
              }
            };

            initAuth();
            return onAuthStateChanged(auth, setUser);
          }, []);

          useEffect(() => {
            if (!user) return;

            const deviceRef = doc(db, DB_COLLECTIONS.devices, user.uid);
            const unsubDevice = onSnapshot(deviceRef, (docSnap) => {
              if (docSnap.exists()) {
                setLinkedProfileIds(docSnap.data().linkedProfiles || []);
              } else {
                setLinkedProfileIds([]);
                setIsLoadingProfile(false);
                setScreen((prev) => (prev === 'loading' ? 'setup' : prev));
              }
            }, (err) => {
              console.error('Device error:', err);
              setErrorText('Das Profil konnte nicht geladen werden.');
            });

            return () => unsubDevice();
          }, [user]);

          useEffect(() => {
            if (!linkedProfileIds.length) {
              setProfiles([]);
              return;
            }

            const ids = linkedProfileIds.slice(0, 10);
            const profilesQuery = query(collection(db, DB_COLLECTIONS.profiles), where(documentId(), 'in', ids));

            const unsubProfiles = onSnapshot(profilesQuery, (snapshot) => {
              const loadedProfiles = snapshot.docs.map((entry) => ({ id: entry.id, ...entry.data() }));
              loadedProfiles.sort((a, b) => (a.name || '').localeCompare(b.name || ''));
              setProfiles(loadedProfiles);
              setIsLoadingProfile(false);
              setScreen((prev) => (prev === 'loading' ? 'profile_select' : prev));
            }, (err) => {
              console.error('Profiles error:', err);
              setIsLoadingProfile(false);
              setErrorText('Profile konnten nicht geladen werden.');
            });

            return () => unsubProfiles();
          }, [linkedProfileIds]);

          const resizeCanvasToDisplay = useCallback((preserveDrawing = false) => {
            const canvas = canvasRef.current;
            if (!canvas) return;

            const { cssWidth, cssHeight } = getCanvasMetrics(canvas);
            const ratio = window.devicePixelRatio || 1;
            const pixelWidth = Math.max(1, Math.round(cssWidth * ratio));
            const pixelHeight = Math.max(1, Math.round(cssHeight * ratio));

            if (canvas.width === pixelWidth && canvas.height === pixelHeight) {
              canvasCssSizeRef.current = { width: cssWidth, height: cssHeight };
              if (!preserveDrawing) {
                const ctx = canvas.getContext('2d');
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
              }
              return;
            }

            let snapshotCanvas = null;
            if (preserveDrawing && canvas.width > 0 && canvas.height > 0) {
              snapshotCanvas = document.createElement('canvas');
              snapshotCanvas.width = canvas.width;
              snapshotCanvas.height = canvas.height;
              const snapshotCtx = snapshotCanvas.getContext('2d');
              snapshotCtx.drawImage(canvas, 0, 0);
            }

            canvas.width = pixelWidth;
            canvas.height = pixelHeight;
            canvasCssSizeRef.current = { width: cssWidth, height: cssHeight };

            const ctx = canvas.getContext('2d');
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            if (snapshotCanvas) {
              ctx.drawImage(snapshotCanvas, 0, 0, snapshotCanvas.width, snapshotCanvas.height, 0, 0, canvas.width, canvas.height);
            }
          }, []);

          useEffect(() => {
            if (screen !== 'game') return;
            resizeCanvasToDisplay(false);
          }, [screen, roundIndex, resizeCanvasToDisplay]);

          useEffect(() => {
            if (screen !== 'game') return;
            const canvas = canvasRef.current;
            if (!canvas) return;

            resizeCanvasToDisplay(true);

            const resizeObserver = new ResizeObserver(() => {
              resizeCanvasToDisplay(true);
            });
            const onWindowResize = () => resizeCanvasToDisplay(true);

            resizeObserver.observe(canvas);
            window.addEventListener('resize', onWindowResize);

            return () => {
              resizeObserver.disconnect();
              window.removeEventListener('resize', onWindowResize);
            };
          }, [screen, resizeCanvasToDisplay]);

          const saveProfile = async () => {
            const name = setupName.trim();
            if (!user || !name) return;

            const profileId = name.toLowerCase();
            const profileRef = doc(db, DB_COLLECTIONS.profiles, profileId);
            const profileSnap = await getDoc(profileRef);

            if (!profileSnap.exists()) {
              await setDoc(profileRef, {
                name,
                avatar: setupAvatar,
                coins: 0,
                unlockedThemes: ['classic'],
                activeTheme: 'classic',
                stickers: []
              });
            } else if (profileSnap.data().avatar !== setupAvatar) {
              await updateDoc(profileRef, { avatar: setupAvatar });
            }

            await setDoc(doc(db, DB_COLLECTIONS.devices, user.uid), {
              linkedProfiles: arrayUnion(profileId)
            }, { merge: true });

            setActiveProfileId(profileId);
            setScreen('start');
            setSetupName('');
            setSetupAvatar('ðŸ¦Š');
          };

          const startGame = () => {
            const difficulty = DIFFICULTY_OPTIONS.find((option) => option.key === selectedDifficulty) || DIFFICULTY_OPTIONS[0];
            const filteredTasks = DRAW_TASKS.filter((task) => task.maxPoints >= difficulty.minPoints && task.maxPoints <= difficulty.maxPoints);
            const taskPool = filteredTasks.length ? filteredTasks : DRAW_TASKS;

            setRoundTasks(shuffle(taskPool).slice(0, Math.min(MAX_ROUNDS, taskPool.length)));
            setRoundIndex(0);
            setScore(0);
            setFeedback('');
            setLastRoundScore(0);
            setLastRoundEmoji('');
            setLastRoundComment('');
            setHasRoundScored(false);
            setGeneratedImageUrl('');
            setResultText('');
            setEarnedCoins(0);
            setErrorText('');
            undoStackRef.current = [];
            setCanUndo(false);
            setScreen('game');
          };

          const getCanvasDataUrl = () => {
            const canvas = canvasRef.current;
            if (!canvas) return '';
            return canvas.toDataURL('image/png');
          };

          const getCanvasDataUrlForDownload = () => {
            const canvas = canvasRef.current;
            if (!canvas) return '';

            const { cssWidth, cssHeight } = getCanvasMetrics(canvas);
            const displayAspect = cssWidth / cssHeight;
            const pixelAspect = canvas.width / canvas.height;

            if (Math.abs(displayAspect - pixelAspect) < 0.001) {
              return canvas.toDataURL('image/png');
            }

            const exportWidth = canvas.width;
            const exportHeight = Math.max(1, Math.round(exportWidth / displayAspect));
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = exportWidth;
            exportCanvas.height = exportHeight;

            const exportCtx = exportCanvas.getContext('2d');
            exportCtx.fillStyle = '#ffffff';
            exportCtx.fillRect(0, 0, exportWidth, exportHeight);
            exportCtx.drawImage(canvas, 0, 0, canvas.width, canvas.height, 0, 0, exportWidth, exportHeight);

            return exportCanvas.toDataURL('image/png');
          };

          const clearCanvas = () => {
            const canvas = canvasRef.current;
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            undoStackRef.current.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
            if (undoStackRef.current.length > UNDO_LIMIT) {
              undoStackRef.current.shift();
            }
            setCanUndo(undoStackRef.current.length > 0);
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            setGeneratedImageUrl('');
          };

          const pointFromEvent = (event) => {
            const canvas = canvasRef.current;
            const { cssWidth, cssHeight, offsetLeft, offsetTop } = getCanvasMetrics(canvas);
            const scaleX = canvas.width / cssWidth;
            const scaleY = canvas.height / cssHeight;
            const cssX = clamp(event.clientX - offsetLeft, 0, cssWidth);
            const cssY = clamp(event.clientY - offsetTop, 0, cssHeight);
            return {
              x: cssX * scaleX,
              y: cssY * scaleY
            };
          };

          const drawSegment = (start, end) => {
            const canvas = canvasRef.current;
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const { width } = canvasCssSizeRef.current;
            const scale = width ? (canvas.width / width) : 1;
            ctx.strokeStyle = brushColor;
            ctx.lineWidth = brushSize * scale;
            ctx.beginPath();
            ctx.moveTo(start.x, start.y);
            ctx.lineTo(end.x, end.y);
            ctx.stroke();
          };

          const fillCanvasAtPoint = (point) => {
            const canvas = canvasRef.current;
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const x = clamp(Math.floor(point.x), 0, width - 1);
            const y = clamp(Math.floor(point.y), 0, height - 1);
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            const startIndex = (y * width + x) * 4;

            const targetR = data[startIndex];
            const targetG = data[startIndex + 1];
            const targetB = data[startIndex + 2];
            const targetA = data[startIndex + 3];
            const fillColor = hexToRgb(brushColor);

            if (targetR === fillColor.r && targetG === fillColor.g && targetB === fillColor.b && targetA === 255) {
              return;
            }

            const matchesTarget = (index) => (
              data[index] === targetR &&
              data[index + 1] === targetG &&
              data[index + 2] === targetB &&
              data[index + 3] === targetA
            );

            const stack = [[x, y]];

            while (stack.length) {
              const [currentX, currentY] = stack.pop();
              if (currentX < 0 || currentY < 0 || currentX >= width || currentY >= height) continue;

              const index = (currentY * width + currentX) * 4;
              if (!matchesTarget(index)) continue;

              data[index] = fillColor.r;
              data[index + 1] = fillColor.g;
              data[index + 2] = fillColor.b;
              data[index + 3] = 255;

              stack.push([currentX + 1, currentY]);
              stack.push([currentX - 1, currentY]);
              stack.push([currentX, currentY + 1]);
              stack.push([currentX, currentY - 1]);
            }

            ctx.putImageData(imageData, 0, 0);
            setGeneratedImageUrl('');
          };

          const undoLastAction = () => {
            const canvas = canvasRef.current;
            if (!canvas || !undoStackRef.current.length) return;
            const ctx = canvas.getContext('2d');
            const previousState = undoStackRef.current.pop();
            if (!previousState) return;
            ctx.putImageData(previousState, 0, 0);
            setCanUndo(undoStackRef.current.length > 0);
            setGeneratedImageUrl('');
          };

          const onPointerDown = (event) => {
            event.preventDefault();
            const point = pointFromEvent(event);

            const canvas = canvasRef.current;
            if (canvas) {
              const ctx = canvas.getContext('2d');
              undoStackRef.current.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
              if (undoStackRef.current.length > UNDO_LIMIT) {
                undoStackRef.current.shift();
              }
              setCanUndo(undoStackRef.current.length > 0);
            }

            if (tool === 'fill') {
              fillCanvasAtPoint(point);
              drawingRef.current = false;
              lastPointRef.current = null;
              return;
            }

            drawingRef.current = true;
            lastPointRef.current = point;
            drawSegment(point, point);
          };

          const onPointerMove = (event) => {
            if (!drawingRef.current || !lastPointRef.current) return;
            event.preventDefault();
            const point = pointFromEvent(event);
            drawSegment(lastPointRef.current, point);
            lastPointRef.current = point;
          };

          const onPointerUp = () => {
            drawingRef.current = false;
            lastPointRef.current = null;
          };

          const downloadBlob = (blob, filename) => {
            const link = document.createElement('a');
            const objectUrl = URL.createObjectURL(blob);
            link.href = objectUrl;
            link.download = filename;
            link.click();
            setTimeout(() => URL.revokeObjectURL(objectUrl), 1500);
          };

          const downloadUrl = async (url, fileBaseName) => {
            if (!url) throw new Error('Kein Bild zum Speichern vorhanden.');

            if (url.startsWith('data:')) {
              const parts = url.match(/^data:([^;]+);/);
              const mimeType = parts?.[1] || 'image/png';
              const response = await fetch(url);
              const blob = await response.blob();
              const extension = extensionFromMime(mimeType);
              downloadBlob(blob, `${fileBaseName}.${extension}`);
              return;
            }

            try {
              const response = await fetch(url);
              if (!response.ok) throw new Error('Download fehlgeschlagen.');
              const blob = await response.blob();
              const extension = extensionFromMime(blob.type);
              downloadBlob(blob, `${fileBaseName}.${extension}`);
            } catch {
              window.open(url, '_blank', 'noopener,noreferrer');
              throw new Error('Direkter Download war nicht mÃ¶glich. Bild wurde in neuem Tab geÃ¶ffnet.');
            }
          };

          const saveOwnDrawing = async () => {
            try {
              setErrorText('');
              const imageDataUrl = getCanvasDataUrlForDownload();
              const promptSlug = sanitizeFilenamePart(currentTask?.prompt, 'motiv');
              await downloadUrl(imageDataUrl, `${fileTimestamp()}-malatelier-${promptSlug}-zeichnung`);
            } catch (error) {
              setErrorText(error.message || 'Zeichnung konnte nicht gespeichert werden.');
            }
          };

          const saveGeneratedImage = async () => {
            try {
              setErrorText('');
              const promptSlug = sanitizeFilenamePart(currentTask?.prompt, 'motiv');
              const modelSlug = sanitizeFilenamePart(imageEditModel, 'ki-modell');
              await downloadUrl(generatedImageUrl, `${fileTimestamp()}-malatelier-${promptSlug}-${modelSlug}-zauberbild`);
            } catch (error) {
              setErrorText(error.message || 'KI-Bild konnte nicht gespeichert werden.');
            }
          };

          const callOpenRouter = async ({ model, messages, responseFormat }) => {
            if (!openRouterApiKey.trim()) {
              throw new Error('Bitte trage einen OpenRouter API-Key ein.');
            }

            const sendRequest = async (includeTemperature) => {
              const body = {
                model,
                messages
              };

              if (includeTemperature) {
                body.temperature = 0.2;
              }

              if (responseFormat) {
                body.response_format = responseFormat;
              }

              return fetch('https://openrouter.ai/api/v1/chat/completions', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `Bearer ${openRouterApiKey.trim()}`,
                  'HTTP-Referer': window.location.href,
                  'X-Title': 'LernKumpel-Malatelier'
                },
                body: JSON.stringify(body)
              });
            };

            let response = await sendRequest(true);

            if (!response.ok) {
              const text = await response.text();
              const rejectsTemperature =
                response.status === 400 &&
                /unsupported parameter[^\n]*temperature|temperature[^\n]*not supported/i.test(text);

              if (rejectsTemperature) {
                response = await sendRequest(false);
                if (!response.ok) {
                  const retryText = await response.text();
                  throw new Error(`KI-API Fehler (${response.status}): ${retryText.slice(0, 220)}`);
                }
                return response.json();
              }

              throw new Error(`KI-API Fehler (${response.status}): ${text.slice(0, 220)}`);
            }

            return response.json();
          };

          const evaluateDrawing = async () => {
            if (!currentTask || hasRoundScored || isBusy) return;

            try {
              setIsBusy(true);
              setErrorText('');
              setFeedback('KI bewertet dein Bild...');

              const imageDataUrl = getCanvasDataUrl();
              const prompt = `Du bist ein KI-Bildbewerter fÃ¼r Kinderzeichnungen. Aufgabe: "Male ${currentTask.prompt}".
                    Bewerte, wie gut die Zeichnung zur Aufgabe passt.
                    AuÃŸerdem soll die QualitÃ¤t (Farben, Details) der Zeichnung berÃ¼cksichtigt werden.
                    Je mehr Details, KreativitÃ¤t und Farbauswahl, desto hÃ¶her die Bewertung.
                    Wenn das Bild schlecht ist, kannst du es mit einem lustigen / sarkastischen Spruch kommentieren (aber in Worten, die kleine Kinder noch verstehen).
                    Antworte nur als JSON mit den Feldern:
                    - score: ganze Zahl 0 bis 100
                    - feedback: kurzer freundlicher Satz auf Deutsch (max 120 Zeichen)
                    - emoji: genau ein passendes Bewertungs-Emoji (z.B. ðŸ¤©, ðŸ™‚, ðŸ˜…, ðŸ˜Ž, ðŸ¥³, ðŸ™ˆ).`;

              const result = await callOpenRouter({
                model: evaluationModel,
                messages: [
                  {
                    role: 'user',
                    content: [
                      { type: 'text', text: prompt },
                      { type: 'image_url', image_url: { url: imageDataUrl } }
                    ]
                  }
                ],
                responseFormat: { type: 'json_object' }
              });

              const text = result?.choices?.[0]?.message?.content || '';
              const parsed = parseJsonFromText(text) || {};
              const aiScore = clamp(Number(parsed.score) || 0, 0, 100);
              const finalScore = Math.round((aiScore / 100) * (currentTask.maxPoints || 100));
              const aiFeedback = (parsed.feedback || 'Danke fÃ¼rs Malen!').toString().slice(0, 120);
              const aiEmoji = (parsed.emoji || '').toString().trim().slice(0, 4);

              setLastRoundScore(finalScore);
              setLastRoundEmoji(aiEmoji || scoreToEmoji(aiScore));
              setLastRoundComment(aiFeedback);
              setHasRoundScored(true);
              setScore((prev) => prev + finalScore);
              setFeedback('');
            } catch (err) {
              console.error(err);
              setErrorText(err.message || 'KI-Bewertung fehlgeschlagen.');
              setFeedback('');
            } finally {
              setIsBusy(false);
            }
          };

          const extractGeneratedImageUrl = (apiResult) => {
            const choice = apiResult?.choices?.[0]?.message;
            if (!choice) return '';

            if (Array.isArray(choice.images) && choice.images[0]?.image_url?.url) {
              return choice.images[0].image_url.url;
            }

            if (Array.isArray(choice.content)) {
              for (const part of choice.content) {
                if (part?.type === 'image_url' && part?.image_url?.url) {
                  return part.image_url.url;
                }
                if (part?.type === 'output_image' && part?.image_url) {
                  return part.image_url;
                }
              }
            }

            const maybeText = choice.content;
            if (typeof maybeText === 'string') {
              const match = maybeText.match(/https?:\/\/\S+/);
              if (match) return match[0];
            }

            return '';
          };

          const createAiImageVariant = async () => {
            if (!profile || !activeProfileId || !currentTask || isBusy) return;

            if ((profile.coins || 0) < AI_EDIT_COST) {
              setErrorText(`Du brauchst mindestens ${AI_EDIT_COST} MÃ¼nzen fÃ¼r den KI-Zauber.`);
              return;
            }

            try {
              setIsBusy(true);
              setIsGeneratingImage(true);
              setErrorText('');

              const imageDataUrl = getCanvasDataUrl();
              const prompt = `Verwandle diese Kinderzeichnung in ein buntes, freundliches Bild im Kinderbuch-Stil. Motiv: ${currentTask.prompt}. Behalte die Grundidee der Zeichnung bei.`;

              const result = await callOpenRouter({
                model: imageEditModel,
                messages: [
                  {
                    role: 'user',
                    content: [
                      { type: 'text', text: prompt },
                      { type: 'image_url', image_url: { url: imageDataUrl } }
                    ]
                  }
                ]
              });

              const generatedUrl = extractGeneratedImageUrl(result);
              if (!generatedUrl) {
                throw new Error('Die KI hat kein Bild zurÃ¼ckgegeben. PrÃ¼fe Modell/API-Key.');
              }

              await updateDoc(doc(db, DB_COLLECTIONS.profiles, activeProfileId), {
                coins: (profile.coins || 0) - AI_EDIT_COST
              });

              setGeneratedImageUrl(generatedUrl);
            } catch (err) {
              console.error(err);
              setErrorText(err.message || 'KI-Bild konnte nicht erstellt werden.');
            } finally {
              setIsGeneratingImage(false);
              setIsBusy(false);
            }
          };

          const finishGame = async (finalScore) => {
            const coins = Math.floor(finalScore / 10);
            setEarnedCoins(coins);

            if (profile && activeProfileId) {
              await updateDoc(doc(db, DB_COLLECTIONS.profiles, activeProfileId), {
                coins: (profile.coins || 0) + coins
              });
            }

            setResultText(finalScore >= 600 ? 'Wow, du bist ein echter Mal-Profi! ðŸŽ¨' : 'Super gemalt! Jede Runde macht dich besser. âœ¨');
            setScreen('result');
          };

          const nextRound = async () => {
            if (!hasRoundScored) {
              setErrorText('Bitte zuerst KI-Bewertung durchfÃ¼hren.');
              return;
            }

            const isLastRound = roundIndex >= roundTasks.length - 1;
            if (isLastRound) {
              await finishGame(score);
              return;
            }

            setRoundIndex((prev) => prev + 1);
            setFeedback('');
            setLastRoundScore(0);
            setLastRoundEmoji('');
            setLastRoundComment('');
            setHasRoundScored(false);
            setErrorText('');
            setGeneratedImageUrl('');
            undoStackRef.current = [];
            setCanUndo(false);
          };

          const selectProfile = (profileId) => {
            setActiveProfileId(profileId);
            setScreen('start');
          };

          const TopBar = () => {
            if (!profile || screen === 'setup' || screen === 'profile_select' || screen === 'loading') return null;

            return (
              <div className="absolute top-0 left-0 w-full p-4 flex justify-between items-start z-30 pointer-events-none">
                <button
                  onClick={() => {
                    setActiveProfileId(null);
                    setScreen('profile_select');
                  }}
                  className="bg-white/90 backdrop-blur-sm rounded-full px-4 py-2 flex items-center gap-2 shadow-md pointer-events-auto border-2 border-white/70"
                >
                  <span className="text-2xl">{profile.avatar}</span>
                  <span className="font-bold text-slate-800 hidden sm:inline">{profile.name}</span>
                  <Users size={16} className="text-indigo-500 ml-1" />
                </button>

                <div className="bg-yellow-300 rounded-full px-4 py-2 flex items-center gap-2 shadow-md pointer-events-auto border-2 border-yellow-200">
                  <span className="font-black text-yellow-900 text-lg">{profile.coins || 0}</span>
                  <span className="text-xl">ðŸª™</span>
                </div>
              </div>
            );
          };

          if (isLoadingProfile) {
            return (
              <div className="min-h-screen bg-indigo-100 flex items-center justify-center font-bold text-xl text-indigo-700">
                Lade...
              </div>
            );
          }

          if (screen === 'profile_select') {
            return (
              <div className="min-h-screen bg-indigo-100 flex flex-col items-center justify-center p-4 font-sans">
                <div className="bg-white rounded-[2rem] shadow-2xl w-full max-w-md p-8 text-center border-4 border-indigo-200 animate-pop-in">
                  <h1 className="text-3xl font-black text-indigo-700 mb-6">Wer malt heute?</h1>

                  <div className="grid grid-cols-2 gap-4 mb-6 max-h-[50vh] overflow-y-auto p-1">
                    {profiles.map((p) => (
                      <button
                        key={p.id}
                        onClick={() => selectProfile(p.id)}
                        className="bg-slate-50 hover:bg-indigo-50 border-2 border-slate-200 hover:border-indigo-300 rounded-2xl p-4 flex flex-col items-center gap-2 transition-all active:scale-95"
                      >
                        <div className="text-5xl">{p.avatar}</div>
                        <div className="font-bold text-slate-700 text-lg truncate w-full">{p.name}</div>
                      </button>
                    ))}
                  </div>

                  <button
                    onClick={() => setScreen('setup')}
                    className="w-full bg-indigo-100 hover:bg-indigo-200 text-indigo-800 font-bold py-4 rounded-2xl flex items-center justify-center gap-2 border-2 border-indigo-200 border-dashed"
                  >
                    <Users size={20} /> Neuen Spieler hinzufÃ¼gen
                  </button>

                  {errorText && <p className="mt-4 text-sm text-red-500 font-semibold">{errorText}</p>}
                </div>
              </div>
            );
          }

          if (screen === 'setup') {
            return (
              <div className="min-h-screen bg-indigo-100 flex flex-col items-center justify-center p-4 font-sans">
                <div className="bg-white rounded-[2rem] shadow-2xl w-full max-w-md p-8 text-center border-4 border-indigo-200 animate-pop-in">
                  <h1 className="text-3xl font-black text-indigo-700 mb-2">Neues Profil</h1>
                  <p className="text-slate-500 font-medium mb-6 text-sm">Nutze denselben Namen wie in Zahlen-Safari/Lese-Fuchs fÃ¼r gemeinsame MÃ¼nzen.</p>

                  <div className="mb-6">
                    <label className="block text-left font-bold text-slate-700 mb-2">Dein Name:</label>
                    <input
                      type="text"
                      maxLength={12}
                      value={setupName}
                      onChange={(event) => setSetupName(event.target.value)}
                      placeholder="z.B. Mia"
                      className="w-full bg-slate-50 border-2 border-indigo-200 rounded-xl px-4 py-3 font-bold text-slate-800 text-xl focus:outline-none focus:border-indigo-500"
                    />
                  </div>

                  <div className="mb-8">
                    <label className="block text-left font-bold text-slate-700 mb-2">WÃ¤hle dein Tier:</label>
                    <div className="grid grid-cols-5 gap-2 bg-slate-50 p-3 rounded-xl border-2 border-slate-100">
                      {AVATAR_POOL.map((avatar) => (
                        <button
                          key={avatar}
                          onClick={() => setSetupAvatar(avatar)}
                          className={`aspect-square text-3xl flex items-center justify-center rounded-lg transition-all ${setupAvatar === avatar ? 'bg-indigo-200 scale-110 shadow-sm' : 'hover:bg-slate-200 opacity-70 hover:opacity-100'}`}
                        >
                          {avatar}
                        </button>
                      ))}
                    </div>
                  </div>

                  <button
                    onClick={saveProfile}
                    disabled={!setupName.trim()}
                    className="w-full bg-green-500 hover:bg-green-600 disabled:bg-slate-300 text-white font-black text-xl py-4 rounded-2xl"
                  >
                    Start!
                  </button>

                  {profiles.length > 0 && (
                    <button onClick={() => setScreen('profile_select')} className="mt-4 text-slate-500 font-bold hover:text-slate-700 underline">
                      Abbrechen
                    </button>
                  )}
                </div>
              </div>
            );
          }

          if (screen === 'start') {
            return (
              <div className="min-h-screen bg-indigo-100 relative flex flex-col items-center justify-center p-4 pt-20 font-sans">
                <TopBar />

                <div className="bg-white rounded-[2rem] shadow-2xl w-full max-w-2xl p-8 text-center border-4 border-indigo-200 animate-pop-in">
                  <div className="text-7xl mb-4 animate-float">ðŸŽ¨</div>
                  <h1 className="text-4xl font-black text-slate-800 mb-2">Mal-<span className="text-indigo-600">Atelier</span></h1>
                  <p className="text-slate-600 font-medium mb-2">Male die vorgegebene Aufgabe und lass die KI dein Bild bewerten.</p>
                  <p className="text-slate-500 font-medium mb-6 text-sm">{MAX_ROUNDS} Aufgaben pro Runde Â· Punkte je nach Motiv</p>

                  <div className="bg-indigo-50 border-2 border-indigo-100 rounded-2xl p-4 mb-4 text-left">
                    <p className="font-bold text-indigo-800 mb-1">So funktioniert's:</p>
                    <ul className="text-slate-600 text-sm space-y-1">
                      <li>â€¢ Male das Motiv mit Farbe und Strichdicke deiner Wahl.</li>
                      <li>â€¢ KI bewertet dein Bild und du erhÃ¤ltst Punkte je nach Schwierigkeit.</li>
                      <li>â€¢ FÃ¼r die Gesamtpunkte bekommst du MÃ¼nzen.</li>
                      <li>â€¢ Optional: Erstelle ein KI-Zauberbild aus deiner Zeichnung fÃ¼r {AI_EDIT_COST} MÃ¼nzen.</li>
                    </ul>
                  </div>

                  <div className="bg-indigo-50 border-2 border-indigo-100 rounded-2xl p-4 mb-6 text-left">
                    <p className="font-bold text-indigo-800 mb-3">Schwierigkeit</p>
                    <div className="grid grid-cols-1 sm:grid-cols-4 gap-2">
                      {DIFFICULTY_OPTIONS.map((option) => (
                        <button
                          key={option.key}
                          onClick={() => setSelectedDifficulty(option.key)}
                          className={`rounded-xl border-2 px-3 py-3 font-black transition ${selectedDifficulty === option.key ? 'bg-indigo-500 text-white border-indigo-500' : 'bg-white text-slate-700 border-indigo-100 hover:bg-indigo-100'}`}
                        >
                          <span className="mr-2" aria-hidden="true">{option.symbol}</span>
                          {option.label}
                        </button>
                      ))}
                    </div>
                  </div>

                  <details
                    open={isApiKeyMissing}
                    className={`border-2 rounded-2xl p-4 mb-6 text-left ${isApiKeyMissing ? 'bg-red-50 border-red-200' : 'bg-slate-50 border-slate-200'}`}
                  >
                    <summary className={`font-bold cursor-pointer ${isApiKeyMissing ? 'text-red-700' : 'text-slate-800'}`}>
                      KI-Einstellungen (OpenRouter) {isApiKeyMissing ? 'â€¢ API-Key fehlt' : ''}
                    </summary>

                    <div className="mt-3 space-y-3">
                      <div className="flex items-center gap-3">
                        <p className={`text-sm font-bold shrink-0 w-32 ${isApiKeyMissing ? 'text-red-700' : 'text-slate-700'}`}>API-Key:</p>
                        <input
                          type="password"
                          value={openRouterApiKey}
                          onChange={(event) => setOpenRouterApiKey(event.target.value)}
                          placeholder="OpenRouter API-Key"
                          className={`flex-1 min-w-0 bg-white border-2 rounded-xl px-3 py-2 text-sm font-semibold ${isApiKeyMissing ? 'border-red-300' : 'border-slate-200'}`}
                        />
                      </div>
                      <div className="flex items-center gap-3">
                        <p className="text-sm font-bold text-slate-700 shrink-0 w-32">Bewertungsmodell:</p>
                        <select
                          value={evaluationModel}
                          onChange={(event) => setEvaluationModel(event.target.value)}
                          className="flex-1 min-w-0 bg-white border-2 border-slate-200 rounded-xl px-3 py-2 text-sm font-semibold"
                        >
                          {EVALUATION_MODEL_OPTIONS.map((option) => (
                            <option key={option.value} value={option.value}>{option.label}</option>
                          ))}
                        </select>
                      </div>
                      <div className="flex items-center gap-3">
                        <p className="text-sm font-bold text-slate-700 shrink-0 w-32">Bildmodell:</p>
                        <select
                          value={imageEditModel}
                          onChange={(event) => setImageEditModel(event.target.value)}
                          className="flex-1 min-w-0 bg-white border-2 border-slate-200 rounded-xl px-3 py-2 text-sm font-semibold"
                        >
                          {IMAGE_EDIT_MODEL_OPTIONS.map((option) => (
                            <option key={option.value} value={option.value}>{option.label}</option>
                          ))}
                        </select>
                      </div>
                    </div>
                  </details>

                  <button
                    onClick={startGame}
                    className="w-full bg-green-500 hover:bg-green-600 text-white font-black text-2xl py-4 rounded-2xl"
                  >
                    Losmalen!
                  </button>

                  <a href="../index.html" className="inline-block mt-4 text-slate-500 font-bold hover:text-slate-700 underline">
                    ZurÃ¼ck zum LernKumpel-MenÃ¼
                  </a>
                </div>
              </div>
            );
          }

          if (screen === 'game') {
            return (
              <div className="min-h-screen bg-indigo-50 relative flex flex-col items-center justify-center p-4 pt-24 font-sans">
                <TopBar />

                <div className="w-full max-w-5xl flex justify-between items-center mb-4 px-1">
                  <div className="bg-white px-5 py-3 rounded-full shadow border-2 border-yellow-100">
                    <span className="text-yellow-500 text-2xl mr-2">â­</span>
                    <span key={score} className="inline-block text-3xl md:text-4xl font-black text-slate-800 animate-score-reveal">{score}</span>
                  </div>
                  <div className="text-indigo-600 font-bold bg-white px-4 py-2 rounded-full shadow">
                    {roundIndex + 1} / {roundTasks.length}
                  </div>
                </div>

                <div className="bg-white rounded-[2rem] shadow-2xl border border-indigo-100 w-full max-w-5xl overflow-hidden animate-pop-in">
                  <div className="p-6 md:p-8">
                    <p className="text-3xl md:text-4xl font-black text-slate-800 leading-tight mb-4">
                      {currentTask?.emoji} {currentTask ? `Male ${currentTask.prompt}` : ''}
                      <span className="text-xl md:text-2xl text-yellow-500 font-bold ml-3 block md:inline mt-2 md:mt-0">
                        <span className="bg-yellow-100 text-yellow-700 px-3 py-1 rounded-full border border-yellow-200 inline-flex items-center gap-1">
                          â­ max. {currentTask?.maxPoints || 100}
                        </span>
                      </span>
                    </p>

                    <div className="bg-slate-100 rounded-2xl p-3 border-2 border-slate-200 mb-4">
                      <canvas
                        ref={canvasRef}
                        onPointerDown={onPointerDown}
                        onPointerMove={onPointerMove}
                        onPointerUp={onPointerUp}
                        onPointerLeave={onPointerUp}
                        className="w-full h-[500px] md:h-[560px] bg-white rounded-xl border-2 border-slate-200"
                        style={{ cursor: tool === 'fill' ? 'crosshair' : 'default' }}
                      />
                    </div>

                    <div className="bg-slate-50 rounded-2xl p-4 border-2 border-slate-200 mb-4">
                      <div className="grid md:grid-cols-3 gap-4 items-end">
                        <div>
                          <p className="font-black text-slate-800 mb-2">ðŸ› ï¸ Werkzeug</p>
                          <div className="grid grid-cols-3 gap-2 mb-2">
                            <button
                              onClick={() => setTool('brush')}
                              title="Stift"
                              className={`py-2 rounded-xl font-bold border-2 ${tool === 'brush' ? 'bg-indigo-500 text-white border-indigo-500' : 'bg-white text-slate-700 border-slate-200 hover:bg-slate-100'}`}
                            >
                              ðŸ–Œï¸
                            </button>
                            <button
                              onClick={() => setTool('fill')}
                              title="Fill"
                              className={`py-2 rounded-xl font-bold border-2 ${tool === 'fill' ? 'bg-indigo-500 text-white border-indigo-500' : 'bg-white text-slate-700 border-slate-200 hover:bg-slate-100'}`}
                            >
                              ðŸª£
                            </button>

                            <button
                              onClick={undoLastAction}
                              disabled={!canUndo}
                              title="Undo"
                              className="py-2 rounded-xl font-bold border-2 bg-amber-400 hover:bg-amber-500 disabled:bg-slate-300 text-slate-900 border-amber-300"
                            >
                              â†©ï¸
                            </button>
                          </div>

                          <p className="text-xs font-bold text-slate-500 mb-3">Cursor: {tool === 'fill' ? 'ðŸª£' : 'ðŸ–Œï¸'}</p>

                          <p className="font-black text-slate-800 mb-2">ðŸŽ¨ Farbe</p>
                          <div className="grid grid-cols-4 gap-2">
                            {BRUSH_COLORS.map((color) => (
                              <button
                                key={color}
                                onClick={() => setBrushColor(color)}
                                className={`w-10 h-10 rounded-full border-4 ${brushColor === color ? 'border-slate-800 scale-110' : 'border-white'}`}
                                style={{ backgroundColor: color }}
                                title={color}
                              />
                            ))}
                          </div>
                        </div>

                        <div>
                          <p className="font-black text-slate-800 mb-1">ðŸ–Œï¸ {brushSize}px</p>
                          <input
                            type="range"
                            min="2"
                            max="30"
                            value={brushSize}
                            onChange={(event) => setBrushSize(Number(event.target.value))}
                            className="w-full"
                          />
                        </div>

                        <div className="grid grid-cols-2 md:grid-cols-1 gap-2">
                          <button
                            onClick={clearCanvas}
                            className="w-full bg-slate-300 hover:bg-slate-400 text-slate-800 font-bold py-2 rounded-xl"
                          >
                            ðŸ§½ Neu
                          </button>

                          <button
                            onClick={saveOwnDrawing}
                            className="w-full bg-emerald-500 hover:bg-emerald-600 text-white font-bold py-2 rounded-xl"
                          >
                            ðŸ’¾ Speichern
                          </button>

                          <button
                            onClick={evaluateDrawing}
                            disabled={isBusy || hasRoundScored}
                            className="w-full bg-indigo-500 hover:bg-indigo-600 disabled:bg-slate-300 text-white font-black py-2 rounded-xl"
                          >
                            {isBusy && !isGeneratingImage ? 'â³' : hasRoundScored ? 'âœ…' : 'ðŸ¤– Bewerten'}
                          </button>

                          <button
                            onClick={createAiImageVariant}
                            disabled={isBusy}
                            className="w-full bg-fuchsia-500 hover:bg-fuchsia-600 disabled:bg-slate-300 text-white font-black py-2 rounded-xl"
                          >
                            {isGeneratingImage ? 'â³ Zauber...' : `ðŸª„ KI (-${AI_EDIT_COST} ðŸª™)`}
                          </button>
                        </div>
                      </div>
                    </div>

                    {(feedback || hasRoundScored || lastRoundComment) && (
                      <div key={`${roundIndex}-${lastRoundScore}-${feedback}`} className="bg-indigo-100 text-indigo-900 p-5 rounded-3xl mb-3 border-2 border-indigo-200 animate-score-reveal">
                        {feedback && !hasRoundScored && <p className="font-black text-xl md:text-2xl leading-tight">{feedback}</p>}
                        {hasRoundScored && (
                          <div className="mt-2 flex items-center justify-center gap-3">
                            <ScoreRing score={lastRoundScore} max={currentTask?.maxPoints || 100} />
                            <div className="w-16 h-16 rounded-full bg-white/70 border-2 border-indigo-200 flex items-center justify-center text-3xl" aria-label="Bewertungs-Emoji">
                              {lastRoundEmoji || scoreToEmoji(lastRoundScore)}
                            </div>
                          </div>
                        )}
                        {lastRoundComment && <p className="text-base mt-2">{lastRoundComment}</p>}
                      </div>
                    )}

                    {generatedImageUrl && (
                      <div className="bg-fuchsia-50 border border-fuchsia-200 p-4 rounded-2xl mb-3">
                        <p className="font-black text-fuchsia-900 mb-2">Dein KI-Zauberbild</p>
                        <img src={generatedImageUrl} alt="KI-Zauberbild" className="w-full h-auto rounded-xl border-2 border-fuchsia-200" />
                        <button
                          onClick={saveGeneratedImage}
                          className="mt-3 w-full bg-fuchsia-500 hover:bg-fuchsia-600 text-white font-bold py-2 rounded-xl"
                        >
                          KI-Bild speichern
                        </button>
                      </div>
                    )}

                    {errorText && <p className="text-red-500 font-semibold text-sm mt-2">{errorText}</p>}

                    <div className="flex items-center justify-between mt-4">
                      <button
                        onClick={() => setScreen('start')}
                        className="bg-slate-500 hover:bg-slate-600 text-white font-bold py-3 px-5 rounded-full shadow"
                        aria-label="ZurÃ¼ck zur Startseite"
                        title="ZurÃ¼ck"
                      >
                        ðŸ 
                      </button>
                      <button
                        onClick={nextRound}
                        className="bg-indigo-500 hover:bg-indigo-600 text-white font-bold py-3 px-6 rounded-full shadow"
                        aria-label={roundIndex >= roundTasks.length - 1 ? 'Runde abschlieÃŸen' : 'NÃ¤chste Aufgabe'}
                        title={roundIndex >= roundTasks.length - 1 ? 'Runde abschlieÃŸen' : 'NÃ¤chste Aufgabe'}
                      >
                        {roundIndex >= roundTasks.length - 1 ? 'ðŸ' : 'âž¡ï¸'}
                      </button>
                    </div>
                  </div>
                </div>
              </div>
            );
          }

          if (screen === 'result') {
            return (
              <div className="min-h-screen bg-yellow-50 relative flex flex-col items-center justify-center p-4 pt-20 font-sans">
                <TopBar />

                <div className="bg-white p-8 rounded-3xl shadow-2xl max-w-md w-full border-4 border-yellow-300 text-center animate-pop-in">
                  <div className="text-7xl mb-4 animate-float">ðŸ–¼ï¸</div>
                  <h1 className="text-4xl font-black text-slate-800 mb-3">Runde fertig!</h1>
                  <p className="text-slate-600 font-semibold mb-6">{resultText}</p>

                  <div className="bg-yellow-100 rounded-2xl p-5 mb-6 border border-yellow-200">
                    <p className="text-slate-700 font-bold">Deine Punkte</p>
                    <p className="text-5xl font-black text-yellow-600 mt-1">{score}</p>
                  </div>

                  <div className="bg-indigo-50 rounded-2xl p-4 mb-6 border border-indigo-100">
                    <p className="text-slate-700 font-bold">MÃ¼nzen aus dieser Runde</p>
                    <p className="text-3xl font-black text-indigo-600 mt-1">+{earnedCoins} ðŸª™</p>
                  </div>

                  <button
                    onClick={() => setScreen('start')}
                    className="w-full bg-indigo-500 hover:bg-indigo-600 text-white font-black py-4 rounded-2xl mb-3"
                  >
                    Noch eine Runde
                  </button>

                  <a href="../index.html" className="text-slate-500 font-bold hover:text-slate-700 underline">
                    ZurÃ¼ck zum LernKumpel-MenÃ¼
                  </a>
                </div>
              </div>
            );
          }

          return null;
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
